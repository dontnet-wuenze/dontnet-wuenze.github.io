"use strict";(self.webpackChunkboss_wiki=self.webpackChunkboss_wiki||[]).push([[8160],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=d(e,["components","mdxType","originalType","parentName"]),h=c(n),m=r,p=h["".concat(l,".").concat(m)]||h[m]||s[m]||i;return n?a.createElement(p,o(o({ref:t},u),{},{components:n})):a.createElement(p,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var d={};for(var l in t)hasOwnProperty.call(t,l)&&(d[l]=t[l]);d.originalType=e,d.mdxType="string"==typeof e?e:r,o[1]=d;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8159:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>s,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={},o=void 0,d={unversionedId:"tech/c++/c++11 \u591a\u7ebf\u7a0b/c++ \u7ebf\u7a0b\u540c\u6b65",id:"tech/c++/c++11 \u591a\u7ebf\u7a0b/c++ \u7ebf\u7a0b\u540c\u6b65",title:"c++ \u7ebf\u7a0b\u540c\u6b65",description:"https://github.com/stanford-cs149/asst2/blob/master/tutorial/README.md",source:"@site/docs/tech/c++/c++11 \u591a\u7ebf\u7a0b/c++ \u7ebf\u7a0b\u540c\u6b65.md",sourceDirName:"tech/c++/c++11 \u591a\u7ebf\u7a0b",slug:"/tech/c++/c++11 \u591a\u7ebf\u7a0b/c++ \u7ebf\u7a0b\u540c\u6b65",permalink:"/docs/tech/c++/c++11 \u591a\u7ebf\u7a0b/c++ \u7ebf\u7a0b\u540c\u6b65",draft:!1,editUrl:"https://github.com/dontnet-wuenze/Wiki_Docusaurus/edit/master/docs/tech/c++/c++11 \u591a\u7ebf\u7a0b/c++ \u7ebf\u7a0b\u540c\u6b65.md",tags:[],version:"current",frontMatter:{},sidebar:"techSidebar",previous:{title:"c++ {}\u63a7\u5236\u4f5c\u7528\u57df",permalink:"/docs/tech/c++/c++ {}\u63a7\u5236\u4f5c\u7528\u57df"},next:{title:"packaged_task \u548c async \u533a\u522b",permalink:"/docs/tech/c++/c++11 \u591a\u7ebf\u7a0b/packaged_task \u548c async \u533a\u522b"}},l={},c=[{value:"\u7ebf\u7a0b(Thread)",id:"\u7ebf\u7a0bthread",level:2},{value:"\u521b\u5efa\u7ebf\u7a0b",id:"\u521b\u5efa\u7ebf\u7a0b",level:3},{value:"\u9500\u6bc1\u7ebf\u7a0b",id:"\u9500\u6bc1\u7ebf\u7a0b",level:3},{value:"\u4e92\u65a5\u9501(Mutexes)",id:"\u4e92\u65a5\u9501mutexes",level:2},{value:"mutex.lock()",id:"mutexlock",level:3},{value:"lock_guard",id:"lock_guard",level:3},{value:"unique_lock",id:"unique_lock",level:3},{value:"\u6761\u4ef6\u53d8\u91cf(Conditional Variables)",id:"\u6761\u4ef6\u53d8\u91cfconditional-variables",level:2},{value:"\u4f7f\u7528\u65b9\u6cd5",id:"\u4f7f\u7528\u65b9\u6cd5",level:3},{value:"wait \u5224\u65ad\u6761\u4ef6",id:"wait-\u5224\u65ad\u6761\u4ef6",level:3}],u={toc:c};function s(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/stanford-cs149/asst2/blob/master/tutorial/README.md"},"https://github.com/stanford-cs149/asst2/blob/master/tutorial/README.md")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://segmentfault.com/a/1190000006614695"},"https://segmentfault.com/a/1190000006614695")),(0,r.kt)("h2",{id:"\u7ebf\u7a0bthread"},"\u7ebf\u7a0b(Thread)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <thread>\n#include <stdio.h>\n\nvoid my_func(int thread_id, int num_threads) {\n    printf("Hello from spawned thread %d of %d\\n", thread_id, num_threads);\n}\n\nint main(int argc, char** argv) {\n\n  std::thread t0 = std::thread(my_func, 0, 2);\n  std::thread t1 = std::thread(my_func, 1, 2);\n\n  printf("The main thread is running concurrently with spawned threads.\\n");\n\n  t0.join();\n  t1.join();\n\n  printf("Spawned threads have terminated at this point.\\n");\n\n  return 0;\n}\n')),(0,r.kt)("h3",{id:"\u521b\u5efa\u7ebf\u7a0b"},"\u521b\u5efa\u7ebf\u7a0b"),(0,r.kt)("p",null,"\u4f7f\u7528 thread \u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b, \u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u6267\u884c\u7684\u51fd\u6570, \u540e\u9762\u662f\u6267\u884c\u51fd\u6570\u7684\u53c2\u6570"),(0,r.kt)("h3",{id:"\u9500\u6bc1\u7ebf\u7a0b"},"\u9500\u6bc1\u7ebf\u7a0b"),(0,r.kt)("p",null,"\u6ce8\u610f\u7ebf\u7a0b\u5728\u9500\u6bc1\u524d\u9700\u8981 join \u6216\u8005 detach, \u5426\u5219\u4f1a\u51fa\u73b0\u9519\u8bef\u3002"),(0,r.kt)("p",null,"A thread object does not have an associated thread (and is safe to destroy) after:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it was default-constructed"),(0,r.kt)("li",{parentName:"ul"},"it was moved from"),(0,r.kt)("li",{parentName:"ul"},"join() has been called"),(0,r.kt)("li",{parentName:"ul"},"detach() has been called")),(0,r.kt)("h2",{id:"\u4e92\u65a5\u9501mutexes"},"\u4e92\u65a5\u9501(Mutexes)"),(0,r.kt)("h3",{id:"mutexlock"},"mutex.lock()"),(0,r.kt)("p",null,"\u76f4\u63a5\u64cd\u4f5c mutex\uff0c\u5373\u76f4\u63a5\u8c03\u7528 mutex \u7684 lock / unlock \u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <condition_variable>\n#include <mutex>\n#include <thread>\n\n#include <stdio.h>\n\n/*\n Wrapper class around an integer counter and a mutex.\n */\nclass Counter {\n    public:\n        int counter_;\n        std::mutex* mutex_;\n        Counter() {\n            counter_ = 0;\n            mutex_ = new std::mutex();\n        }\n        ~Counter() {\n            delete mutex_;\n        }\n};\n\nvoid increment_counter_fn(Counter* counter) {\n    for (int i = 0; i < 10000; i++) {\n        // Call lock() method to acquire lock.\n        counter->mutex_->lock();\n        // Since multiple threads are trying to perform an increment, the\n        // increment needs to be protected by a mutex.\n        counter->counter_++;\n        // Call unlock() method to release lock.\n        counter->mutex_->unlock();\n    }\n}\n\n/*\n * Threads increment a shared counter in a tight for loop 10,000 times.\n */\nvoid mutex_example() {\n    int num_threads = 8;\n\n    printf("==============================================================\\n");\n    printf("Starting %d threads to increment counter...\\n", num_threads);\n    std::thread* threads = new std::thread[num_threads];\n    Counter* counter = new Counter();\n    // `num_threads` threads will call `increment_counter_fn`, trying to\n    // increment `counter`.\n    for (int i = 0; i < num_threads; i++) {\n        threads[i] = std::thread(increment_counter_fn, counter);\n    }\n    // Wait for spawned threads to complete.\n    for (int i = 0; i < num_threads; i++) {\n        threads[i].join();\n    }\n    // Verify that final counter value is (10000 * `num_threads`).\n    printf("Final counter value: %d...\\n", counter->counter_);\n    printf("==============================================================\\n");\n\n    delete counter;\n    delete[] threads;\n}\n')),(0,r.kt)("h3",{id:"lock_guard"},"lock_guard"),(0,r.kt)("p",null,"\u53ef\u4ee5\u4f7f\u7528\u5c01\u88c5\u597d\u7684 lock_guard, \u7c7b\u4f3c\u667a\u80fd\u6307\u9488, \u51fd\u6570\u7ed3\u675f\u4f1a\u81ea\u52a8\u91ca\u653e\u9501\u3002"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nstd::mutex g_mutex;\nint g_count = 0;\n\nvoid Counter() {\n  // lock_guard \u5728\u6784\u9020\u51fd\u6570\u91cc\u52a0\u9501\uff0c\u5728\u6790\u6784\u51fd\u6570\u91cc\u89e3\u9501\u3002\n  std::lock_guard<std::mutex> lock(g_mutex);\n\n  int i = ++g_count;\n  std::cout << "count: " << i << std::endl;\n}\n\nint main() {\n  const std::size_t SIZE = 4;\n\n  std::vector<std::thread> v;\n  v.reserve(SIZE);\n\n  for (std::size_t i = 0; i < SIZE; ++i) {\n    v.emplace_back(&Counter);\n  }\n\n  for (std::thread& t : v) {\n    t.join();\n  }\n\n  return 0;\n}\n')),(0,r.kt)("h3",{id:"unique_lock"},"unique_lock"),(0,r.kt)("p",null,"\u5728 lock \u4e0a\u7684\u7528\u6cd5\u548c lock_guard \u76f8\u540c, \u4f46\u662f unique_lock \u53ef\u4ee5\u914d\u5408\u6761\u4ef6\u9501\u4f7f\u7528\u3002"),(0,r.kt)("h2",{id:"\u6761\u4ef6\u53d8\u91cfconditional-variables"},"\u6761\u4ef6\u53d8\u91cf(Conditional Variables)"),(0,r.kt)("h3",{id:"\u4f7f\u7528\u65b9\u6cd5"},"\u4f7f\u7528\u65b9\u6cd5"),(0,r.kt)("p",null,"\u9996\u5148\u83b7\u53d6 mutex \u9501(\u4f7f\u7528 unique_lock), \u7136\u540e\u8c03\u7528 wait(lock)\u3002\u8fd9\u4e00\u6b65\u4f1a\u4f7f\u7ebf\u7a0b\u4f11\u7720\u5e76\u91ca\u653e mutex \u8d44\u6e90\u3002\u5f53 Conditional Variable \u8c03\u7528 .notify()\u65f6, \u4f1a\u5524\u9192\u4e00\u4e2a\u7ebf\u7a0b\u3002\u6b64\u65f6\u7ebf\u7a0b\u4f1a\u91cd\u65b0\u83b7\u53d6\u5230 mutex \u9501(\u6ce8\u610f\u5982\u679c mutex \u4e0d\u662f\u7a7a\u95f2\u7684, \u7ebf\u7a0b\u4f9d\u7136\u4f1a\u88ab\u5524\u9192, \u4f46\u662f\u8981\u7b49\u5f85\u9501\u8d44\u6e90\u88ab\u5176\u4ed6\u7ebf\u7a0b\u91ca\u653e)\u3002"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'/*\n * Wrapper class around a counter, a condition variable, and a mutex.\n */\nclass ThreadState {\n    public:\n        std::condition_variable* condition_variable_;\n        std::mutex* mutex_;\n        int counter_;\n        int num_waiting_threads_;\n        ThreadState(int num_waiting_threads) {\n            condition_variable_ = new std::condition_variable();\n            mutex_ = new std::mutex();\n            counter_ = 0;\n            num_waiting_threads_ = num_waiting_threads;\n        }\n        ~ThreadState() {\n            delete condition_variable_;\n            delete mutex_;\n        }\n};\n\nvoid signal_fn(ThreadState* thread_state) {\n    // Acquire mutex to make sure the shared counter is read in a\n    // consistent state.\n    thread_state->mutex_->lock();\n    while (thread_state->counter_ < thread_state->num_waiting_threads_) {\n        thread_state->mutex_->unlock();\n        // Release the mutex before calling `notify_all()` to make sure\n        // waiting threads have a chance to make progress.\n        thread_state->condition_variable_->notify_all();\n        // Re-acquire the mutex to read the shared counter again.\n        thread_state->mutex_->lock();\n    }\n    thread_state->mutex_->unlock();\n}\n\nvoid wait_fn(ThreadState* thread_state) {\n    // A lock must be held in order to wait on a condition variable.\n    // This lock is atomically released before the thread goes to sleep\n    // when `wait()` is called. The lock is atomically re-acquired when\n    // the thread is woken up using `notify_all()`.\n    std::unique_lock<std::mutex> lk(*thread_state->mutex_);\n    thread_state->condition_variable_->wait(lk);\n    // Increment the shared counter with the lock re-acquired to inform the\n    // signaling thread that this waiting thread has successfully been\n    // woken up.\n    thread_state->counter_++;\n    printf("Lock re-acquired after wait()...\\n");\n    lk.unlock();\n}\n\n/*\n * Signaling thread spins until each waiting thread increments a shared\n * counter after being woken up from the `wait()` method.\n */\nvoid condition_variable_example() {\n    int num_threads = 3;\n\n    printf("==============================================================\\n");\n    printf("Starting %d threads for signal-and-waiting...\\n", num_threads);\n    std::thread* threads = new std::thread[num_threads];\n    ThreadState* thread_state = new ThreadState(num_threads-1);\n    threads[0] = std::thread(signal_fn, thread_state);\n    for (int i = 1; i < num_threads; i++) {\n        threads[i] = std::thread(wait_fn, thread_state);\n    }\n    for (int i = 0; i < num_threads; i++) {\n        threads[i].join();\n    }\n    printf("==============================================================\\n");\n\n    delete thread_state;\n    delete[] threads;\n}\n')),(0,r.kt)("h3",{id:"wait-\u5224\u65ad\u6761\u4ef6"},"wait \u5224\u65ad\u6761\u4ef6"),(0,r.kt)("p",null,"wait \u88ab notify \u89e6\u53d1\u65f6\uff0c \u53ef\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u51fd\u6570\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u6761\u4ef6, \u5426\u5219\u7ee7\u7eed\u963b\u585e\u5728 wait \u4e2d\u3002"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\nmutex mutex_;\ncondition_variable condVar;\nbool someCondition = false;\n\nvoid waitThread() {\n    unique_lock<mutex> lock(mutex_);\n    cout << "acquire the mutex in waitThread" << endl;\n    condVar.wait(lock, []{return someCondition;});\n    cout << "wait end and get lock" << endl;\n}\n\nvoid signalThread() {\n    cout << "in signalThread" << endl;\n    unique_lock<mutex> lock(mutex_);\n    cout << "acquire the mutex in signalThread" << endl;\n    condVar.notify_all();\n    cout << "notify the thread" << endl;\n    cout << "hold the lock" << endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    lock.unlock();\n    someCondition = true;\n    condVar.notify_all();\n    return ;\n}\n\n\nint main()\n{\n    thread thread1 = thread(waitThread);\n    //thread1.join();\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    thread thread2 = thread(signalThread);\n    thread1.join();\n    thread2.join();\n}\n')))}s.isMDXComponent=!0}}]);